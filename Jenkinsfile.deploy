/// changed the "waitfor for cluster stage"
pipeline {
    agent any

    environment {
        CLUSTER_NAME = 'pythonapp.k8s.local'
        KOPS_STATE_STORE = 's3://pragra-kops'
        AWS_REGION = 'us-east-1'
        ZONES = 'us-east-1a,us-east-1b'
        IMAGE_NAME = 'vishyswaminathan/python-image'
        IMAGE_TAG = 'latest'
        HELM_CHART_PATH = 'helm/pythonapp-charts'
        SSH_PUBLIC_KEY_PATH = '/var/lib/jenkins/.ssh/id_ed25519.pub'
    }

    stages {
        stage('Verify AWS Configuration') {
            steps {
                script {
                    sh """
                    echo "‚úÖ Verifying AWS configuration..."
                    aws sts get-caller-identity
                    aws s3 ls ${KOPS_STATE_STORE} || echo "S3 bucket access verified"
                    """
                }
            }
        }

        stage('Verify SSH Key Exists') {
            steps {
                script {
                    sh """
                    if [ ! -f ${SSH_PUBLIC_KEY_PATH} ]; then
                        echo "‚ùå ERROR: SSH public key not found at ${SSH_PUBLIC_KEY_PATH}"
                        exit 1
                    else
                        echo "‚úÖ SSH key found at ${SSH_PUBLIC_KEY_PATH}"
                    fi
                    """
                }
            }
        }

        stage('Create Kubernetes Cluster with Kops') {
            steps {
                script {
                    sh """
                    export AWS_DEFAULT_REGION=${AWS_REGION}
                    export KOPS_STATE_STORE=${KOPS_STATE_STORE}
                    export NAME=${CLUSTER_NAME}

                    echo "üîß Creating Kubernetes cluster: ${CLUSTER_NAME}"

                    # Create cluster only if it doesn't already exist
                    if ! kops get cluster --name=\${NAME} --state=\${KOPS_STATE_STORE} > /dev/null 2>&1; then
                        kops create cluster --name=\${NAME} \\
                            --state=\${KOPS_STATE_STORE} \\
                            --zones=${ZONES} \\
                            --dns private \\
                            --node-count=2 \\
                            --node-size=t3.small \\
                            --master-size=t3.medium \\
                            --node-volume-size=12 \\
                            --master-volume-size=12 \\
                            --ssh-public-key=${SSH_PUBLIC_KEY_PATH} \\
                            --yes
                    else
                        echo "‚ö†Ô∏è Cluster already exists. Skipping creation."
                    fi
                    """
                }
            }
        }

        stage('Wait for Cluster to be Ready') {
    steps {
        script {
            echo "‚è≥ Waiting for cluster to become ready..."

            sh """
            export AWS_DEFAULT_REGION=${AWS_REGION}
            export KOPS_STATE_STORE=${KOPS_STATE_STORE}
            export NAME=${CLUSTER_NAME}

            echo "üì° Waiting for Kubernetes API to be reachable..."

            for i in {1..15}; do
                echo "üîç Attempt \$i/15: Validating cluster..."
                if kops validate cluster --name=\${NAME} --state=\${KOPS_STATE_STORE}; then
                    echo "‚úÖ Cluster validation passed!"
                    break
                else
                    echo "üïí Cluster not ready yet. Sleeping 30 seconds..."
                    sleep 30
                fi

                if [ \$i -eq 15 ]; then
                    echo "‚ùå Cluster did not become ready in time."
                    exit 1
                fi
            done

            echo "üìÇ Exporting kubeconfig for Helm..."
            kops export kubeconfig --admin --name=\${NAME}

            # Double-check that API is reachable before Helm runs
            for i in {1..10}; do
                if kubectl get nodes > /dev/null 2>&1; then
                    echo "‚úÖ kubectl can access the cluster."
                    break
                else
                    echo "üì∂ Waiting for DNS/API to be resolvable..."
                    sleep 20
                fi
            done
            """
        }
    }
}


        stage('Deploy Application with Helm') {
            steps {
                script {
                    sh """
                    echo "üßπ Cleaning up any previous Helm install..."
                    helm uninstall python-app 2>/dev/null || true

                    echo "üöÄ Deploying application using Helm..."
                    helm upgrade --install python-app ${HELM_CHART_PATH} \\
                        --set image.repository=${IMAGE_NAME} \\
                        --set image.tag=${IMAGE_TAG} \\
                        --wait \\
                        --timeout 10m \\
                        --atomic \\
                        --debug
                    """
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    sh """
                    echo "üîç Verifying application deployment..."
                    kubectl rollout status deployment/python-app --timeout=300s
                    kubectl get pods -o wide
                    echo "üåê Application endpoint:"
                    kubectl get svc python-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "‚ö†Ô∏è Service may not be using a LoadBalancer"
                    """
                }
            }
        }
    }

    post {
        success {
            echo "‚úÖ Cluster created and application deployed successfully!"
        }
        failure {
            echo "‚ùå Pipeline failed. Check the logs above."
            script {
                sh """
                echo "üì¶ Gathering diagnostics..."
                export AWS_DEFAULT_REGION=${AWS_REGION}
                kops validate cluster --name=${CLUSTER_NAME} --state=${KOPS_STATE_STORE} --cloud-only || true
                kops get clusters --state=${KOPS_STATE_STORE} || true

                echo "üß® Cleaning up cluster..."
                kops delete cluster --name=${CLUSTER_NAME} --yes || true
                """
            }
        }
    }
}
